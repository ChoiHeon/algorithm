<정규 표현식 기초>
* import re를 통해 정규식 사용 가능

* 문자 클래스 []
  - [abc]: a or b or c 가 있는지
  - [a-z]: a ~ z까지의 문자들 중 하나 이상이 있는지
  ex) [a-zA-z]
       [0-9]

* dot (.)
  - a.b: a + 임의의 문자열 + b, 
  - "abc"는 a와 b사이에 문자열이 없으므로 성립하지 않음
  - a[.]b의 '.'는 임의의 문자열을 의미하는 것이 아닌, 있는 그대로의 '.'를 의미

* 반복 (*a)
  - a*b: a를 0개 이상 반복 가능 --> {b, ab, aab, aaab, ... }

* 반복 (+)
  - a+b: a를 1개 이상 반복 가능 --> {ab, aab, aaab, ... }

* 반복 ({m, n}), (?)
  - ca{2, 4}t: a를 2~4회 반복 가능
  - ca?t: a를 0번 이상 1번 이사 반복 가능 --> 즉, 생략이 가능함을 의미

* 시작 (^)
  - "^python": python으로 시작하는 문자열

* 끝 ($)
  - "python$": python으로 끝나는 문자열

* 제외 (^)
  - 문자 클래스 내의 '^'는 not을 의미
  - [^xy]: x or y를 제외한 문자 하나

* 그룹화 (())
  - 괄호 안의 내용만을 그룹화
  - aa(.+?)bb: 해당 패턴을 만족하는 문자열에 대해 괄호안의 문자열

====================================================================
<파이썬에서 정규 표현식을 위한 re 모듈>
* re.compile
  - p = re.complie("ab*") --> p는 패턴 객체, 패턴이란 정규 표현식을 컴파일한 결과
 
* m = p.match("문자열")
  - 패턴과 문자열이 일치할 경우 match 객체를 반환
  - 일치 하지 않을 경우 None을 반환
  - 공백을 통해 문자열이 구분될 경우, m.group()을 통해 일치하는 문자열을 반환 가능

* s = p.search("문자열")
  - 대상 문자열의 모든 시작 부분에 대하여 탐색

* match vs search
  - match: 대상 문자열의 0번 인덱스부터 시작하여 패턴과 일치하는지 확인
    즉, 중간에 있는 패턴과 일치하는 문자열을 찾지 못함
  - search: 대상 문자열 중간에 있는, 패턴과 일치하는 문자열을 찾을 수 있음
    그러나, ()를 통한 그룹화가 되지 않음

* findall("문자열")
  - 공백으로 문자열을 구분할 수 있을 경우
  - 일치하는 문자열들을 리스트 객체로 반환

* finditer("문자열')
  - findall과 달리 iterable 객체를 반환
  - 각 원소는 match 객체








































